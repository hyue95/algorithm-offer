<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
/* 
广度优先搜索
思路：
对于 「Tree 的 BFS」 （典型的「单源 BFS」） 大家都已经轻车熟路了：

首先把 root 节点入队，再一层一层无脑遍历就行了。
对于 「图 的 BFS」 （「多源 BFS」） 做法其实也是一样滴～，与 「Tree 的 BFS」的区别注意以下两条就 ok 辣～

Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；
Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过哦！并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问！【 看见很多人说自己的 BFS 超时了，坑就在这里哈哈哈
做法：
根据上述思路，本题怎么做就很简单了：

首先把每个源点 0 入队，然后从各个 0 同时开始一圈一圈的向 1 扩散
（每个 1 都是被离它最近的 0 扩散到的 ），扩散的时候可以设置 int[][] dist 
来记录距离（即扩散的层次）并同时标志是否访问过。
对于本题是可以直接修改原数组 int[][] matrix 来记录距离和标志是否访问的，这里要注意先把 matrix 数组中 1 的位置设置成 -1 （设成Integer.MAX_VALUE啦，m * n啦，10000啦都行，只要是个无效的距离值来标志这个位置的 1 没有被访问过就行辣~）

作者：sweetiee
链接：https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 */

//广度优先搜索（多点发散，层序遍历）
var updateMatrix = function(matrix) {
  let queue = []
  let m = matrix.length
  if(m === 0) return []
  let n = matrix[0].length
  for(let i = 0; i < m; i ++){
    for(let j = 0; j < n; j ++){
      if(matrix[i][j] === 0){
        queue.push([i, j])
      }else{
        matrix[i][j] = -1
      }
    }
  }
  let dx = [-1, 1, 0, 0]
  let dy = [0, 0, -1, 1]
  while(queue.length){
    let point = queue.shift()
    let x = point[0], y = point[1]
    for(let i = 0; i < 4; i ++){
      let newX = x + dx[i]
      let newY = y + dy[i]
      if(newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] === -1){
        matrix[newX][newY] = matrix[x][y] + 1
        queue.push([newX, newY])
      }
    }
  }
  return matrix
};

  </script>
</body>
</html>